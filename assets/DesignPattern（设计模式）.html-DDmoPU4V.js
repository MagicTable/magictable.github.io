import{_ as i,c as a,a as o,b as l,d as t,e as s,w as e,r as u,o as d}from"./app-D67BBu3k.js";const E={};function p(g,n){const r=u("RouteLink");return d(),a("div",null,[n[48]||(n[48]=o('<p><strong>文章摘要：</strong> 设计模式是一组经过验证的代码结构或模板，用于解决常见的设计问题。</p><h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h2><p>设计模式的作用</p><ul><li>设计模式是解决常见设计问题的经验总结，它提供了一种通用的、最佳实践的解决方案。</li><li>设计模式可以帮助我们更好地组织代码，提高代码的可重用性、可维护性和可扩展性。</li></ul><p>设计模式的分类</p><ul><li><strong>创建型设计模式</strong>（5种）：单例模式、原型模式、工厂方法模式、抽象工厂模式、建造者模式</li><li><strong>结构型设计模式</strong>（7种）：代理模式、适配器模式、桥接模式、装饰器模式、外观模式、享元模式、组合模式</li><li><strong>行为型设计模式</strong>（11种）：责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式、访问者模式</li></ul><h2 id="基础知识" tabindex="-1"><a class="header-anchor" href="#基础知识"><span>基础知识</span></a></h2><h3 id="设计模式七大原则" tabindex="-1"><a class="header-anchor" href="#设计模式七大原则"><span>设计模式七大原则</span></a></h3><div class="hint-container note"><p class="hint-container-title">注释</p><p>设计模式的七大原则通常被称为“SOLID原则”，是面向对象设计中的基本原则，能够帮助开发人员编写出更加灵活、可扩展、可维护的代码。</p></div>',9)),l("p",null,[n[1]||(n[1]=t("详细总结：")),s(r,{to:"/software/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99.html"},{default:e(()=>n[0]||(n[0]=[t("基础知识-设计模式七大原则")])),_:1,__:[0]})]),n[49]||(n[49]=o('<h2 id="创建型设计模式-5种" tabindex="-1"><a class="header-anchor" href="#创建型设计模式-5种"><span>创建型设计模式（5种）</span></a></h2><div class="hint-container note"><p class="hint-container-title">注释</p></div><h3 id="单例模式" tabindex="-1"><a class="header-anchor" href="#单例模式"><span>单例模式</span></a></h3><ul><li><strong>英文</strong>：Singleton Pattern</li><li><strong>简要说明</strong>：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</li></ul>',4)),l("p",null,[n[3]||(n[3]=t("详细总结：")),s(r,{to:"/software/DesignPattern-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html"},{default:e(()=>n[2]||(n[2]=[t("单例模式")])),_:1,__:[2]})]),n[50]||(n[50]=l("h3",{id:"原型模式",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#原型模式"},[l("span",null,"原型模式")])],-1)),n[51]||(n[51]=l("ul",null,[l("li",null,[l("strong",null,"英文"),t("：Prototype Pattern")]),l("li",null,[l("strong",null,"简要说明"),t("：通过复制现有的实例来创建新的对象，而不是使用构造函数。")])],-1)),l("p",null,[n[5]||(n[5]=t("详细总结：")),s(r,{to:"/software/DesignPattern-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.html"},{default:e(()=>n[4]||(n[4]=[t("原型模式")])),_:1,__:[4]})]),n[52]||(n[52]=l("h3",{id:"工厂方法模式",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#工厂方法模式"},[l("span",null,"工厂方法模式")])],-1)),n[53]||(n[53]=l("ul",null,[l("li",null,[l("strong",null,"英文"),t("：Factory Pattern")]),l("li",null,[l("strong",null,"简要说明"),t("：定义一个创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。")])],-1)),l("p",null,[n[7]||(n[7]=t("详细总结：")),s(r,{to:"/software/DesignPattern-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.html"},{default:e(()=>n[6]||(n[6]=[t("工厂方法模式")])),_:1,__:[6]})]),n[54]||(n[54]=l("h3",{id:"抽象工厂模式",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#抽象工厂模式"},[l("span",null,"抽象工厂模式")])],-1)),n[55]||(n[55]=l("ul",null,[l("li",null,[l("strong",null,"英文"),t("：Abstract Factory Pattern")]),l("li",null,[l("strong",null,"简要说明"),t("：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。")])],-1)),l("p",null,[n[9]||(n[9]=t("详细总结：")),s(r,{to:"/software/DesignPattern-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html"},{default:e(()=>n[8]||(n[8]=[t("抽象工厂模式")])),_:1,__:[8]})]),n[56]||(n[56]=l("h3",{id:"建造者模式",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#建造者模式"},[l("span",null,"建造者模式")])],-1)),n[57]||(n[57]=l("ul",null,[l("li",null,[l("strong",null,"英文"),t("：Builder Pattern")]),l("li",null,[l("strong",null,"简要说明"),t("：将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。")])],-1)),l("p",null,[n[11]||(n[11]=t("详细总结：")),s(r,{to:"/software/DesignPattern-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.html"},{default:e(()=>n[10]||(n[10]=[t("建造者模式")])),_:1,__:[10]})]),n[58]||(n[58]=o('<h2 id="结构型设计模式-7种" tabindex="-1"><a class="header-anchor" href="#结构型设计模式-7种"><span>结构型设计模式（7种）</span></a></h2><div class="hint-container note"><p class="hint-container-title">注释</p></div><h3 id="代理模式" tabindex="-1"><a class="header-anchor" href="#代理模式"><span>代理模式</span></a></h3><ul><li><strong>英文</strong>：Proxy Pattern</li><li><strong>简要说明</strong>：为其他对象提供一种代理以控制对这个对象的访问。代理对象可以在被代理对象执行操作前后进行一些预处理和后处理。</li></ul>',4)),l("p",null,[n[13]||(n[13]=t("详细总结：")),s(r,{to:"/software/DesignPattern-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.html"},{default:e(()=>n[12]||(n[12]=[t("代理模式")])),_:1,__:[12]})]),n[59]||(n[59]=l("h3",{id:"适配器模式",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#适配器模式"},[l("span",null,"适配器模式")])],-1)),n[60]||(n[60]=l("ul",null,[l("li",null,[l("strong",null,"英文"),t("：Adapter Pattern")]),l("li",null,[l("strong",null,"简要说明"),t("：将一个类的接口转换成客户端所期望的另一个接口，使得原本由于接口不兼容而无法协同工作的类能够一起工作。")])],-1)),l("p",null,[n[15]||(n[15]=t("详细总结：")),s(r,{to:"/software/DesignPattern-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.html"},{default:e(()=>n[14]||(n[14]=[t("适配器模式")])),_:1,__:[14]})]),n[61]||(n[61]=l("h3",{id:"桥接模式",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#桥接模式"},[l("span",null,"桥接模式")])],-1)),n[62]||(n[62]=l("ul",null,[l("li",null,[l("strong",null,"英文"),t("：Bridge Pattern")]),l("li",null,[l("strong",null,"简要说明"),t("：将抽象部分与它的实现部分分离，使它们都可以独立地变化。")])],-1)),l("p",null,[n[17]||(n[17]=t("详细总结：")),s(r,{to:"/software/DesignPattern-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.html"},{default:e(()=>n[16]||(n[16]=[t("桥接模式")])),_:1,__:[16]})]),n[63]||(n[63]=l("h3",{id:"装饰器模式",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#装饰器模式"},[l("span",null,"装饰器模式")])],-1)),n[64]||(n[64]=l("ul",null,[l("li",null,[l("strong",null,"英文"),t("：Decorator Pattern")]),l("li",null,[l("strong",null,"简要说明"),t("：可以在不改变对象结构的情况下，动态地给对象添加一些额外的职责。提供了一种灵活的替代继承的方式。")])],-1)),l("p",null,[n[19]||(n[19]=t("详细总结：")),s(r,{to:"/software/DesignPattern-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F.html"},{default:e(()=>n[18]||(n[18]=[t("装饰器模式")])),_:1,__:[18]})]),n[65]||(n[65]=l("h3",{id:"门面模式",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#门面模式"},[l("span",null,"门面模式")])],-1)),n[66]||(n[66]=l("ul",null,[l("li",null,[l("strong",null,"英文"),t("：Facade Pattern")]),l("li",null,"又称：外观模式"),l("li",null,[l("strong",null,"简要说明"),t("：为子系统中的一组接口提供一个一致的界面，使得子系统更容易使用。提供了一个统一的接口，用于隐藏系统的复杂性，并使得子系统更加易于使用。")])],-1)),l("p",null,[n[21]||(n[21]=t("详细总结：")),s(r,{to:"/software/DesignPattern-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F.html"},{default:e(()=>n[20]||(n[20]=[t("门面模式")])),_:1,__:[20]})]),n[67]||(n[67]=l("h3",{id:"享元模式",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#享元模式"},[l("span",null,"享元模式")])],-1)),n[68]||(n[68]=l("ul",null,[l("li",null,[l("strong",null,"英文"),t("：Flyweight Pattern")]),l("li",null,[l("strong",null,"简要说明"),t("：运用共享技术来有效地支持大量细粒度对象的复用。")])],-1)),l("p",null,[n[23]||(n[23]=t("详细总结：")),s(r,{to:"/software/DesignPattern-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.html"},{default:e(()=>n[22]||(n[22]=[t("享元模式")])),_:1,__:[22]})]),n[69]||(n[69]=l("h3",{id:"组合模式",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#组合模式"},[l("span",null,"组合模式")])],-1)),n[70]||(n[70]=l("ul",null,[l("li",null,[l("strong",null,"英文"),t("：Composite Pattern")]),l("li",null,[l("strong",null,"简要说明"),t("：将对象组合成树形结构以表示部分-整体的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。")])],-1)),l("p",null,[n[25]||(n[25]=t("详细总结：")),s(r,{to:"/software/DesignPattern-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.html"},{default:e(()=>n[24]||(n[24]=[t("组合模式")])),_:1,__:[24]})]),n[71]||(n[71]=o('<h2 id="行为型设计模式-11种" tabindex="-1"><a class="header-anchor" href="#行为型设计模式-11种"><span>行为型设计模式（11种）</span></a></h2><div class="hint-container note"><p class="hint-container-title">注释</p></div><h3 id="模板方法模式" tabindex="-1"><a class="header-anchor" href="#模板方法模式"><span>模板方法模式</span></a></h3><ul><li><strong>英文</strong>：Template Method Pattern</li><li><strong>简要说明</strong>：定义一个算法框架，并将一些步骤延迟到子类中实现，以便在不改变算法结构的情况下，允许子类重定义算法的某些步骤。</li></ul>',4)),l("p",null,[n[27]||(n[27]=t("详细总结：")),s(r,{to:"/software/DesignPattern-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.html"},{default:e(()=>n[26]||(n[26]=[t("模板方法模式")])),_:1,__:[26]})]),n[72]||(n[72]=l("h3",{id:"策略模式",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#策略模式"},[l("span",null,"策略模式")])],-1)),n[73]||(n[73]=l("ul",null,[l("li",null,[l("strong",null,"英文"),t("：Strategy Pattern")]),l("li",null,[l("strong",null,"简要说明"),t("：定义一系列算法，将每个算法都封装起来，并使它们之间可以互换。策略模式使得算法可以独立于使用它的客户而变化。")])],-1)),l("p",null,[n[29]||(n[29]=t("详细总结：")),s(r,{to:"/software/DesignPattern-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html"},{default:e(()=>n[28]||(n[28]=[t("策略模式")])),_:1,__:[28]})]),n[74]||(n[74]=l("h3",{id:"命令模式",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#命令模式"},[l("span",null,"命令模式")])],-1)),n[75]||(n[75]=l("ul",null,[l("li",null,[l("strong",null,"英文"),t("：Command Pattern")]),l("li",null,[l("strong",null,"简要说明"),t("：将请求封装成一个对象，从而使你可以用不同的请求对客户进行参数化。命令模式也支持撤销操作。")])],-1)),l("p",null,[n[31]||(n[31]=t("详细总结：")),s(r,{to:"/software/DesignPattern-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.html"},{default:e(()=>n[30]||(n[30]=[t("命令模式")])),_:1,__:[30]})]),n[76]||(n[76]=l("h3",{id:"责任链模式",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#责任链模式"},[l("span",null,"责任链模式")])],-1)),n[77]||(n[77]=l("ul",null,[l("li",null,[l("strong",null,"英文"),t("：Chain of Responsibility Pattern")]),l("li",null,[l("strong",null,"简要说明"),t("：为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。")])],-1)),l("p",null,[n[33]||(n[33]=t("详细总结：")),s(r,{to:"/software/DesignPattern-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.html"},{default:e(()=>n[32]||(n[32]=[t("责任链模式")])),_:1,__:[32]})]),n[78]||(n[78]=l("h3",{id:"状态模式",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#状态模式"},[l("span",null,"状态模式")])],-1)),n[79]||(n[79]=l("ul",null,[l("li",null,[l("strong",null,"英文"),t("：State Pattern")]),l("li",null,[l("strong",null,"简要说明"),t("：允许对象在其内部状态发生改变时改变它的行为。对象看起来似乎修改了它的类。")])],-1)),l("p",null,[n[35]||(n[35]=t("详细总结：")),s(r,{to:"/software/DesignPattern-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.html"},{default:e(()=>n[34]||(n[34]=[t("状态模式")])),_:1,__:[34]})]),n[80]||(n[80]=l("h3",{id:"观察者模式",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#观察者模式"},[l("span",null,"观察者模式")])],-1)),n[81]||(n[81]=l("ul",null,[l("li",null,[l("strong",null,"英文"),t("：Observer Pattern")]),l("li",null,"又称：订阅者模式"),l("li",null,[l("strong",null,"简要说明"),t("：定义对象间的一种一对多的依赖关系，使得每当一个对象状态发生改变时，所有依赖它的对象都会得到通知并自动更新。")])],-1)),l("p",null,[n[37]||(n[37]=t("详细总结：")),s(r,{to:"/software/DesignPattern-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.html"},{default:e(()=>n[36]||(n[36]=[t("观察者模式")])),_:1,__:[36]})]),n[82]||(n[82]=l("h3",{id:"中介者模式",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#中介者模式"},[l("span",null,"中介者模式")])],-1)),n[83]||(n[83]=l("ul",null,[l("li",null,[l("strong",null,"英文"),t("：Mediator Pattern")]),l("li",null,[l("strong",null,"简要说明"),t("：用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。")])],-1)),l("p",null,[n[39]||(n[39]=t("详细总结：")),s(r,{to:"/software/DesignPattern-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F.html"},{default:e(()=>n[38]||(n[38]=[t("中介者模式")])),_:1,__:[38]})]),n[84]||(n[84]=l("h3",{id:"迭代器模式",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#迭代器模式"},[l("span",null,"迭代器模式")])],-1)),n[85]||(n[85]=l("ul",null,[l("li",null,[l("strong",null,"英文"),t("：Iterator Pattern")]),l("li",null,[l("strong",null,"简要说明"),t("：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。")])],-1)),l("p",null,[n[41]||(n[41]=t("详细总结：")),s(r,{to:"/software/DesignPattern-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.html"},{default:e(()=>n[40]||(n[40]=[t("迭代器模式")])),_:1,__:[40]})]),n[86]||(n[86]=l("h3",{id:"访问者模式",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#访问者模式"},[l("span",null,"访问者模式")])],-1)),n[87]||(n[87]=l("ul",null,[l("li",null,[l("strong",null,"英文"),t("：Visitor Pattern")]),l("li",null,[l("strong",null,"简要说明"),t("：是一种行为型设计模式，它可以让你在不修改对象结构的前提下，定义作用于这些对象元素的新操作。")])],-1)),l("p",null,[n[43]||(n[43]=t("详细总结：")),s(r,{to:"/software/DesignPattern-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.html"},{default:e(()=>n[42]||(n[42]=[t("访问者模式")])),_:1,__:[42]})]),n[88]||(n[88]=l("h3",{id:"备忘录模式",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#备忘录模式"},[l("span",null,"备忘录模式")])],-1)),n[89]||(n[89]=l("ul",null,[l("li",null,[l("strong",null,"英文"),t("：Memento Pattern")]),l("li",null,[l("strong",null,"简要说明"),t("：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。备忘录模式可以在需要时将对象恢复到先前的状态。")])],-1)),l("p",null,[n[45]||(n[45]=t("详细总结：")),s(r,{to:"/software/DesignPattern-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F.html"},{default:e(()=>n[44]||(n[44]=[t("备忘录模式")])),_:1,__:[44]})]),n[90]||(n[90]=l("h3",{id:"解释器模式",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#解释器模式"},[l("span",null,"解释器模式")])],-1)),n[91]||(n[91]=l("ul",null,[l("li",null,[l("strong",null,"英文"),t("：Interpreter Pattern")]),l("li",null,[l("strong",null,"简要说明"),t("：是一种行为型设计模式，它提供了一种方法，可以在运行时解释语言文法中的表达式，并执行相应的操作。")])],-1)),l("p",null,[n[47]||(n[47]=t("详细总结：")),s(r,{to:"/software/DesignPattern-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F.html"},{default:e(()=>n[46]||(n[46]=[t("解释器模式")])),_:1,__:[46]})])])}const f=i(E,[["render",p]]),m=JSON.parse('{"path":"/software/DesignPattern%EF%BC%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%89.html","title":"DesignPattern（设计模式）","lang":"zh-CN","frontmatter":{"title":"DesignPattern（设计模式）","author":"魔术桌","cover":"","category":["软件程序/设计模式"],"tag":["进度-已完成","知识总结"],"date":"2024-06-17T00:00:00.000Z","star":true,"description":"文章摘要： 设计模式是一组经过验证的代码结构或模板，用于解决常见的设计问题。 简介 设计模式的作用 设计模式是解决常见设计问题的经验总结，它提供了一种通用的、最佳实践的解决方案。 设计模式可以帮助我们更好地组织代码，提高代码的可重用性、可维护性和可扩展性。 设计模式的分类 创建型设计模式（5种）：单例模式、原型模式、工厂方法模式、抽象工厂模式、建造者模...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"DesignPattern（设计模式）\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-06-17T00:00:00.000Z\\",\\"dateModified\\":\\"2025-10-02T13:54:50.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"魔术桌\\"}]}"],["meta",{"property":"og:url","content":"https://blog.magictable.ha.cn/software/DesignPattern%EF%BC%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%89.html"}],["meta",{"property":"og:site_name","content":"魔术桌"}],["meta",{"property":"og:title","content":"DesignPattern（设计模式）"}],["meta",{"property":"og:description","content":"文章摘要： 设计模式是一组经过验证的代码结构或模板，用于解决常见的设计问题。 简介 设计模式的作用 设计模式是解决常见设计问题的经验总结，它提供了一种通用的、最佳实践的解决方案。 设计模式可以帮助我们更好地组织代码，提高代码的可重用性、可维护性和可扩展性。 设计模式的分类 创建型设计模式（5种）：单例模式、原型模式、工厂方法模式、抽象工厂模式、建造者模..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-02T13:54:50.000Z"}],["meta",{"property":"article:author","content":"魔术桌"}],["meta",{"property":"article:tag","content":"知识总结"}],["meta",{"property":"article:tag","content":"进度-已完成"}],["meta",{"property":"article:published_time","content":"2024-06-17T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-02T13:54:50.000Z"}]]},"git":{"updatedTime":1759413290000,"contributors":[{"name":"MagicTable-RedmiNote12TPro-Android","username":"","email":"13459588094@163.com","commits":1},{"name":"MagicTable-HappinessHome-DebianLinux","username":"","email":"13459588094@163.com","commits":1}],"changelog":[{"hash":"ea490d819f6b9c38b6faf647221faa9808862172","time":1759413290000,"email":"13459588094@163.com","author":"MagicTable-HappinessHome-DebianLinux","message":"更新博客文章数据"},{"hash":"bd68b5c596d6a0543e6461d26edd64a5440f6020","time":1758421995000,"email":"13459588094@163.com","author":"MagicTable-RedmiNote12TPro-Android","message":"初始化仓库版本"}]},"autoDesc":true,"filePathRelative":"software/DesignPattern（设计模式）.md","excerpt":"<p><strong>文章摘要：</strong> 设计模式是一组经过验证的代码结构或模板，用于解决常见的设计问题。</p>\\n"}');export{f as comp,m as data};
