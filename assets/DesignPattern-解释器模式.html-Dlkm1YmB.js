import{_ as s,c as a,a as e,o as p}from"./app-wlfcSj72.js";const t={};function l(c,n){return p(),a("div",null,n[0]||(n[0]=[e(`<p><strong>文章摘要：</strong> 定义了如何为语言创建解释器，用来解释该语言中的句子。</p><h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h2><p>简要说明</p><ul><li>解释器模式（Interpreter Pattern）是一种行为型设计模式。</li><li>为语言中的每个符号都定义了一个解释器类，用来处理这个符号相关的解释操作。这些解释器类通常形成一个树状结构，以表示语言的层次结构。</li></ul><p>主要功能</p><ul><li>定义文法的表示方式。</li><li>提供解释器来解释文法表示。</li></ul><p>注意事项</p><ul><li>解释器模式可能会引起类膨胀，因为每种文法规则都需要一个解释器类。</li><li>对于复杂文法，解释器模式可能会变得难以维护和扩展。</li><li>应该只在语言经常变化且运行时效率不是关键问题时使用解释器模式。</li></ul><p>适用场景</p><ul><li>当需要实现一个简单的语言时。</li><li>当效率不是关键问题，且语言的文法较为简单时。</li><li>当一个语言需要解释执行，并且可以将该语言中的句子表示为一个抽象语法树时。</li></ul><h2 id="java-8" tabindex="-1"><a class="header-anchor" href="#java-8"><span>Java 8</span></a></h2><p>案例</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token comment">// 抽象表达式，声明一个抽象的解释操作</span></span>
<span class="line"><span class="token keyword">interface</span> <span class="token class-name">Expression</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">boolean</span> <span class="token function">interpret</span><span class="token punctuation">(</span><span class="token class-name">String</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 终结符表达式，实现了抽象表达式接口，用来处理终结符</span></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">TerminalExpression</span> <span class="token keyword">implements</span> <span class="token class-name">Expression</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">String</span> data<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">TerminalExpression</span><span class="token punctuation">(</span><span class="token class-name">String</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token annotation punctuation">@Override</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">interpret</span><span class="token punctuation">(</span><span class="token class-name">String</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 判断上下文中是否包含终结符</span></span>
<span class="line">        <span class="token keyword">return</span> context<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 非终结符表达式，实现了抽象表达式接口，用来处理非终结符</span></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">OrExpression</span> <span class="token keyword">implements</span> <span class="token class-name">Expression</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">Expression</span> expr1 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">Expression</span> expr2 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">OrExpression</span><span class="token punctuation">(</span><span class="token class-name">Expression</span> expr1<span class="token punctuation">,</span> <span class="token class-name">Expression</span> expr2<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>expr1 <span class="token operator">=</span> expr1<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>expr2 <span class="token operator">=</span> expr2<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token annotation punctuation">@Override</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">interpret</span><span class="token punctuation">(</span><span class="token class-name">String</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 对两个表达式执行逻辑或操作</span></span>
<span class="line">        <span class="token keyword">return</span> expr1<span class="token punctuation">.</span><span class="token function">interpret</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token operator">||</span> expr2<span class="token punctuation">.</span><span class="token function">interpret</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 客户端代码</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InterpreterPatternDemo</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 规则：Robert 和 John 是男性</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Expression</span> <span class="token function">getMaleExpression</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">Expression</span> robert <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TerminalExpression</span><span class="token punctuation">(</span><span class="token string">&quot;Robert&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token class-name">Expression</span> john <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TerminalExpression</span><span class="token punctuation">(</span><span class="token string">&quot;John&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">OrExpression</span><span class="token punctuation">(</span>robert<span class="token punctuation">,</span> john<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">Expression</span> isMale <span class="token operator">=</span> <span class="token function">getMaleExpression</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// 测试解释器</span></span>
<span class="line">        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;John is male? &quot;</span> <span class="token operator">+</span> isMale<span class="token punctuation">.</span><span class="token function">interpret</span><span class="token punctuation">(</span><span class="token string">&quot;John&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Julie is male? &quot;</span> <span class="token operator">+</span> isMale<span class="token punctuation">.</span><span class="token function">interpret</span><span class="token punctuation">(</span><span class="token string">&quot;Julie&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container note"><p class="hint-container-title">注释</p><ul><li>在这个例子中，我们定义了一个简单的语言，该语言可以用来判断一个字符串是否表示男性名字。我们创建了两个类<code>TerminalExpression</code>和<code>OrExpression</code>来分别处理终结符和非终结符。</li><li><code>Expression</code>接口定义了<code>interpret</code>方法，该方法接受一个字符串上下文并返回一个布尔值。</li><li><code>TerminalExpression</code>类是终结符表达式的实现，它检查上下文中是否包含特定的字符串。</li><li><code>OrExpression</code>类是非终结符表达式的实现，它将两个表达式进行逻辑或操作。</li><li>在客户端代码<code>InterpreterPatternDemo</code>中，我们定义了一个规则，即&quot;Robert&quot;和&quot;John&quot;都是男性名字。我们创建了一个<code>OrExpression</code>对象来表示这个规则，并在<code>main</code>方法中测试了这个解释器。</li></ul></div>`,14)]))}const i=s(t,[["render",l]]),r=JSON.parse('{"path":"/software/DesignPattern-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F.html","title":"DesignPattern - 解释器模式","lang":"zh-CN","frontmatter":{"title":"DesignPattern - 解释器模式","author":"魔术桌","cover":"","category":["软件程序/设计模式"],"date":"2024-11-18T00:00:00.000Z","tag":["进度-已完成","知识总结"],"description":"文章摘要： 定义了如何为语言创建解释器，用来解释该语言中的句子。 简介 简要说明 解释器模式（Interpreter Pattern）是一种行为型设计模式。 为语言中的每个符号都定义了一个解释器类，用来处理这个符号相关的解释操作。这些解释器类通常形成一个树状结构，以表示语言的层次结构。 主要功能 定义文法的表示方式。 提供解释器来解释文法表示。 注意事...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"DesignPattern - 解释器模式\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-11-18T00:00:00.000Z\\",\\"dateModified\\":\\"2025-10-03T09:56:57.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"魔术桌\\"}]}"],["meta",{"property":"og:url","content":"https://blog.magictable.ha.cn/software/DesignPattern-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F.html"}],["meta",{"property":"og:site_name","content":"魔术桌"}],["meta",{"property":"og:title","content":"DesignPattern - 解释器模式"}],["meta",{"property":"og:description","content":"文章摘要： 定义了如何为语言创建解释器，用来解释该语言中的句子。 简介 简要说明 解释器模式（Interpreter Pattern）是一种行为型设计模式。 为语言中的每个符号都定义了一个解释器类，用来处理这个符号相关的解释操作。这些解释器类通常形成一个树状结构，以表示语言的层次结构。 主要功能 定义文法的表示方式。 提供解释器来解释文法表示。 注意事..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-03T09:56:57.000Z"}],["meta",{"property":"article:author","content":"魔术桌"}],["meta",{"property":"article:tag","content":"知识总结"}],["meta",{"property":"article:tag","content":"进度-已完成"}],["meta",{"property":"article:published_time","content":"2024-11-18T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-03T09:56:57.000Z"}]]},"git":{"updatedTime":1759485417000,"contributors":[{"name":"MagicTable-RedmiNote12TPro-Android","username":"","email":"13459588094@163.com","commits":1},{"name":"MagicTable-HappinessHome-DebianLinux","username":"","email":"13459588094@163.com","commits":2}],"changelog":[{"hash":"2f64e32c6bfa04fdb137fc5247de26e5603a0eb3","time":1759485417000,"email":"13459588094@163.com","author":"MagicTable-HappinessHome-DebianLinux","message":"vault backup: 2025-10-03 17:56:57"},{"hash":"ea490d819f6b9c38b6faf647221faa9808862172","time":1759413290000,"email":"13459588094@163.com","author":"MagicTable-HappinessHome-DebianLinux","message":"更新博客文章数据"},{"hash":"bd68b5c596d6a0543e6461d26edd64a5440f6020","time":1758421995000,"email":"13459588094@163.com","author":"MagicTable-RedmiNote12TPro-Android","message":"初始化仓库版本"}]},"autoDesc":true,"filePathRelative":"software/DesignPattern-解释器模式.md","excerpt":"<p><strong>文章摘要：</strong> 定义了如何为语言创建解释器，用来解释该语言中的句子。</p>\\n"}');export{i as comp,r as data};
