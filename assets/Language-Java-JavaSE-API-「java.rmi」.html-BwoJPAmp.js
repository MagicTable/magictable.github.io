import{_ as e,c as t,a as o,o as i}from"./app-wlfcSj72.js";const r={};function n(s,a){return i(),t("div",null,a[0]||(a[0]=[o('<p><strong>文章摘要：</strong> 允许一个 Java 虚拟机上的对象调用另一个 Java 虚拟机上对象的方法。</p><h2 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍"><span>介绍</span></a></h2><p>简要说明</p><ul><li>允许一个 Java 虚拟机上的对象调用另一个 Java 虚拟机上对象的方法。</li><li>实现远程过程调用（RPC）机制，使得在不同 JVM 之间可以进行方法调用，就像本地调用一样。</li></ul><p>主要功能</p><ul><li><strong>远程对象</strong>：允许对象在不同 JVM 之间进行通信，这些对象被称为远程对象。</li><li><strong>stub 和 skeleton</strong>：stub 是远程对象的本地代理，它负责将调用转发给远程对象。skeleton 是在服务器端运行的，用于接收来自 stub 的调用并转发给实际的远程对象。</li><li><strong>RMI 注册表</strong>：提供了一个注册表服务，允许远程对象通过名称绑定和查找。</li><li><strong>RMI 查找</strong>：客户端使用 Naming 类来查找远程对象。</li><li><strong>远程接口</strong>：定义了远程对象必须实现的接口，这些接口的方法可以远程调用。</li><li><strong>序列化</strong>：RMI 使用 Java 序列化机制来传输对象，因此远程对象及其参数和返回值必须实现 <code>Serializable</code> 接口。</li></ul><p>注意事项</p><ul><li><strong>安全性</strong>：RMI 调用可能会跨越不安全的网络，因此需要考虑使用安全策略文件来限制远程对象的访问。</li><li><strong>异常处理</strong>：远程方法调用可能会抛出 <code>RemoteException</code>，调用者需要捕获并处理这些异常。</li><li><strong>性能</strong>：RMI 调用涉及网络通信，因此性能可能不如本地方法调用。应尽量减少远程调用次数，并优化数据传输。</li><li><strong>防火墙和端口</strong>：RMI 需要特定的端口来通信，可能需要在防火墙上配置端口转发规则。</li><li><strong>版本兼容性</strong>：客户端和服务器端的远程接口和实现类需要保持版本兼容，否则可能发生序列化错误。</li></ul><p>适用场景</p><ul><li><strong>分布式系统</strong>：在分布式系统中，不同服务器上的组件需要相互通信和协作。</li><li><strong>远程服务</strong>：创建可以被远程客户端调用的服务，如数据库服务、文件服务等。</li><li><strong>跨网络操作</strong>：在需要跨网络执行操作的场景，例如在不同的数据中心之间同步数据。</li><li><strong>企业应用集成</strong>：在企业应用集成中，使用 RMI 可以实现不同系统之间的方法调用和数据交换。</li></ul><h3 id="主要概念" tabindex="-1"><a class="header-anchor" href="#主要概念"><span>主要概念</span></a></h3><h4 id="远程接口-remote-interface" tabindex="-1"><a class="header-anchor" href="#远程接口-remote-interface"><span>远程接口（Remote Interface）</span></a></h4><p>远程接口是标记接口，用于指示哪些方法可以从远程 Java 虚拟机上调用。任何实现远程接口的类都必须声明为 <code>Serializable</code>，并且其所有方法都必须抛出 <code>RemoteException</code>。</p><h4 id="远程对象-remote-object" tabindex="-1"><a class="header-anchor" href="#远程对象-remote-object"><span>远程对象（Remote Object）</span></a></h4><p>实现了远程接口的类的实例，可以被远程访问。</p><h4 id="stub-和-skeleton" tabindex="-1"><a class="header-anchor" href="#stub-和-skeleton"><span>Stub 和 Skeleton</span></a></h4><ul><li><strong>Stub</strong>: 是远程对象的本地代理，它实现了远程接口，并负责将调用转发给远程对象。</li><li><strong>Skeleton</strong>: 是一个存在于服务器端的辅助类，它负责接收来自网络的调用，并将它们传递给远程对象。从 Java 2 平台开始，Skeleton 类在运行时自动生成，因此不再需要手动编写。</li></ul><h4 id="rmi-注册表-rmi-registry" tabindex="-1"><a class="header-anchor" href="#rmi-注册表-rmi-registry"><span>RMI 注册表（RMI Registry）</span></a></h4><p>RMI 注册表是一个服务，它允许远程客户端查找并调用服务器上的远程对象。</p><h3 id="主要类和接口" tabindex="-1"><a class="header-anchor" href="#主要类和接口"><span>主要类和接口</span></a></h3><h4 id="remoteexception" tabindex="-1"><a class="header-anchor" href="#remoteexception"><span>RemoteException</span></a></h4><ul><li><code>RemoteException</code> 是大多数 RMI 方法抛出的异常，表示在远程方法调用过程中发生了错误。</li></ul><h4 id="remote" tabindex="-1"><a class="header-anchor" href="#remote"><span>Remote</span></a></h4><ul><li><code>Remote</code> 是一个标记接口，用于指示对象可以接受远程调用。</li></ul><h4 id="remoteobject" tabindex="-1"><a class="header-anchor" href="#remoteobject"><span>RemoteObject</span></a></h4><ul><li><code>RemoteObject</code> 是 <code>Remote</code> 接口的直接实现，提供了支持远程对象实现的基本功能。</li></ul><h4 id="unicastremoteobject" tabindex="-1"><a class="header-anchor" href="#unicastremoteobject"><span>UnicastRemoteObject</span></a></h4><ul><li><code>UnicastRemoteObject</code> 是 <code>RemoteObject</code> 的子类，用于创建单播远程对象，即一次只能由一个客户端调用的对象。</li></ul><h4 id="naming" tabindex="-1"><a class="header-anchor" href="#naming"><span>Naming</span></a></h4><ul><li><code>Naming</code> 类提供了用于将远程对象绑定到 RMI 注册表和查找远程对象的方法。</li><li><code>bind(String name, Remote obj)</code>: 将指定的名称绑定到远程对象。</li><li><code>lookup(String name)</code>: 查找并返回指定名称的远程对象引用。</li></ul><h4 id="rmisecuritymanager" tabindex="-1"><a class="header-anchor" href="#rmisecuritymanager"><span>RMISecurityManager</span></a></h4><ul><li><code>RMISecurityManager</code> 是用于 RMI 调用的安全管理器，负责检查权限。</li></ul><h3 id="学习总结" tabindex="-1"><a class="header-anchor" href="#学习总结"><span>学习总结</span></a></h3><h4 id="创建远程对象" tabindex="-1"><a class="header-anchor" href="#创建远程对象"><span>创建远程对象</span></a></h4><ol><li>定义一个远程接口，该接口扩展 <code>Remote</code> 并声明要远程调用的方法。</li><li>实现该接口，并在实现类中扩展 <code>UnicastRemoteObject</code>。</li><li>通过 <code>exportObject</code> 方法导出远程对象。</li></ol><h4 id="注册远程对象" tabindex="-1"><a class="header-anchor" href="#注册远程对象"><span>注册远程对象</span></a></h4><ol><li>启动 RMI 注册表服务。</li><li>使用 <code>Naming</code> 类的 <code>bind</code> 方法将远程对象绑定到注册表中。</li></ol><h4 id="访问远程对象" tabindex="-1"><a class="header-anchor" href="#访问远程对象"><span>访问远程对象</span></a></h4><ol><li>使用 <code>Naming</code> 类的 <code>lookup</code> 方法从注册表中获取远程对象的引用。</li><li>调用远程对象的方法，就像调用本地对象一样。</li></ol><h4 id="注意事项" tabindex="-1"><a class="header-anchor" href="#注意事项"><span>注意事项</span></a></h4><ul><li><strong>序列化</strong>: 远程对象及其参数和返回值必须实现 <code>Serializable</code> 接口。</li><li><strong>异常处理</strong>: 所有远程方法都必须声明抛出 <code>RemoteException</code>。</li><li><strong>安全性</strong>: RMI 调用可能会跨越不同的安全域，因此需要考虑安全性和权限管理。</li><li><strong>网络</strong>: RMI 调用依赖于网络，因此网络配置和防火墙设置可能会影响 RMI 的使用。</li></ul><h4 id="rmi-的局限性" tabindex="-1"><a class="header-anchor" href="#rmi-的局限性"><span>RMI 的局限性</span></a></h4><ul><li>RMI 仅限于 Java 环境，不支持跨语言调用。</li><li>性能可能不如其他 RPC 框架，如 gRPC 或 Apache Thrift。</li><li>配置较为复杂，尤其是在涉及安全性和网络问题时。</li></ul><h2 id="java-rmi-activation" tabindex="-1"><a class="header-anchor" href="#java-rmi-activation"><span><code>java.rmi.activation</code></span></a></h2><p>提供对 RMI 对象激活的支持。</p><h2 id="java-rmi-dgc" tabindex="-1"><a class="header-anchor" href="#java-rmi-dgc"><span><code>java.rmi.dgc</code></span></a></h2><p>为 RMI 分布式垃圾回收 （DGC） 提供类和接口。</p><h2 id="java-rmi-registry" tabindex="-1"><a class="header-anchor" href="#java-rmi-registry"><span><code>java.rmi.registry</code></span></a></h2><p>为 RMI 注册表提供一个类和两个接口。</p><h2 id="java-rmi-server" tabindex="-1"><a class="header-anchor" href="#java-rmi-server"><span><code>java.rmi.server</code></span></a></h2><p>提供用于支持 RMI 服务器端的类和接口。</p>',51)]))}const l=e(r,[["render",n]]),d=JSON.parse('{"path":"/software/Language-Java-JavaSE-API-%E3%80%8Cjava.rmi%E3%80%8D.html","title":"Language - Java - Java SE - API - 「java.rmi」","lang":"zh-CN","frontmatter":{"title":"Language - Java - Java SE - API - 「java.rmi」","author":"魔术桌","cover":"","category":["软件程序/程序语言"],"date":"2024-12-24T00:00:00.000Z","tag":["进度-待完善","知识总结"],"description":"文章摘要： 允许一个 Java 虚拟机上的对象调用另一个 Java 虚拟机上对象的方法。 介绍 简要说明 允许一个 Java 虚拟机上的对象调用另一个 Java 虚拟机上对象的方法。 实现远程过程调用（RPC）机制，使得在不同 JVM 之间可以进行方法调用，就像本地调用一样。 主要功能 远程对象：允许对象在不同 JVM 之间进行通信，这些对象被称为远程...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Language - Java - Java SE - API - 「java.rmi」\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-12-24T00:00:00.000Z\\",\\"dateModified\\":\\"2025-11-16T09:17:23.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"魔术桌\\"}]}"],["meta",{"property":"og:url","content":"https://blog.magictable.ha.cn/software/Language-Java-JavaSE-API-%E3%80%8Cjava.rmi%E3%80%8D.html"}],["meta",{"property":"og:site_name","content":"魔术桌"}],["meta",{"property":"og:title","content":"Language - Java - Java SE - API - 「java.rmi」"}],["meta",{"property":"og:description","content":"文章摘要： 允许一个 Java 虚拟机上的对象调用另一个 Java 虚拟机上对象的方法。 介绍 简要说明 允许一个 Java 虚拟机上的对象调用另一个 Java 虚拟机上对象的方法。 实现远程过程调用（RPC）机制，使得在不同 JVM 之间可以进行方法调用，就像本地调用一样。 主要功能 远程对象：允许对象在不同 JVM 之间进行通信，这些对象被称为远程..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-11-16T09:17:23.000Z"}],["meta",{"property":"article:author","content":"魔术桌"}],["meta",{"property":"article:tag","content":"知识总结"}],["meta",{"property":"article:tag","content":"进度-待完善"}],["meta",{"property":"article:published_time","content":"2024-12-24T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-11-16T09:17:23.000Z"}]]},"git":{"updatedTime":1763284643000,"contributors":[{"name":"MagicTable-RedmiNote12TPro-Android","username":"","email":"13459588094@163.com","commits":1},{"name":"MagicTable-HappinessHome-DebianLinux","username":"","email":"13459588094@163.com","commits":2}],"changelog":[{"hash":"443a7028bb64edb6b3d96b66e17ea9bc6a6c790a","time":1763284643000,"email":"13459588094@163.com","author":"MagicTable-HappinessHome-DebianLinux","message":"vault backup: 2025-11-16 17:17:23"},{"hash":"ea490d819f6b9c38b6faf647221faa9808862172","time":1759413290000,"email":"13459588094@163.com","author":"MagicTable-HappinessHome-DebianLinux","message":"更新博客文章数据"},{"hash":"bd68b5c596d6a0543e6461d26edd64a5440f6020","time":1758421995000,"email":"13459588094@163.com","author":"MagicTable-RedmiNote12TPro-Android","message":"初始化仓库版本"}]},"autoDesc":true,"filePathRelative":"software/Language-Java-JavaSE-API-「java.rmi」.md","excerpt":"<p><strong>文章摘要：</strong> 允许一个 Java 虚拟机上的对象调用另一个 Java 虚拟机上对象的方法。</p>\\n"}');export{l as comp,d as data};
