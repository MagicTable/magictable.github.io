import{_ as s,c as a,a as e,o as p}from"./app-D67BBu3k.js";const t={};function o(c,n){return p(),a("div",null,n[0]||(n[0]=[e(`<p><strong>文章摘要：</strong> 装饰器模式使用总结。</p><h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h2><p>简要说明</p><ul><li>装饰器模式（Decorator Pattern）是一种结构型设计模式。</li><li>允许向一个现有的对象添加新的功能，同时又不改变其结构。</li><li>这种模式属于对象结构型模式，它是作为现有类的一个包装。</li></ul><p>主要功能</p><ul><li>在不改变接口的前提下，增强类的性能。</li><li>通过使用不同的具体装饰类以及这些装饰类的排列组合，可以实现不同的效果。</li><li>可以对一个对象进行多次装饰，创造出不同行为的组合。</li></ul><p>注意事项</p><ul><li>装饰器模式会产生很多小对象，这些小对象增加了系统的复杂度。</li><li>装饰器模式比继承更加灵活，但是过度使用会导致系统中类的数目迅速增加。</li><li>应该在确有必要时使用装饰器模式，避免无谓的装饰。</li></ul><p>适用场景</p><ul><li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li><li>当不能采用生成子类的方法进行扩充时，如类定义被隐藏或者类定义是终极类。</li></ul><h2 id="java-8" tabindex="-1"><a class="header-anchor" href="#java-8"><span>Java 8</span></a></h2><p>案例</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token comment">// 定义一个Component接口，这是装饰者和被装饰者的共同接口</span></span>
<span class="line"><span class="token keyword">interface</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 定义一个操作方法，所有实现类都需要实现这个方法</span></span>
<span class="line">    <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// ConcreteComponent是Component接口的具体实现，它是被装饰的对象</span></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">ConcreteComponent</span> <span class="token keyword">implements</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 实现operation方法</span></span>
<span class="line">    <span class="token annotation punctuation">@Override</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;ConcreteComponent operation&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// Decorator是一个抽象类，实现了Component接口，用于扩展Component的功能</span></span>
<span class="line"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Decorator</span> <span class="token keyword">implements</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 持有一个Component类型的引用，可以是ConcreteComponent或者另一个Decorator</span></span>
<span class="line">    <span class="token keyword">protected</span> <span class="token class-name">Component</span> component<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// 构造方法，接收一个Component对象</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">Decorator</span><span class="token punctuation">(</span><span class="token class-name">Component</span> component<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>component <span class="token operator">=</span> component<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// 实现operation方法，调用被装饰对象的operation方法</span></span>
<span class="line">    <span class="token annotation punctuation">@Override</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        component<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// ConcreteDecoratorA是Decorator的具体实现，它添加了额外的行为</span></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">ConcreteDecoratorA</span> <span class="token keyword">extends</span> <span class="token class-name">Decorator</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 构造方法，调用父类的构造方法</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">ConcreteDecoratorA</span><span class="token punctuation">(</span><span class="token class-name">Component</span> component<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">super</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// 重写operation方法，在调用被装饰对象的方法之后添加额外的行为</span></span>
<span class="line">    <span class="token annotation punctuation">@Override</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用被装饰对象的operation方法</span></span>
<span class="line">        <span class="token function">addedBehavior</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 添加额外的行为</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// 添加额外的行为</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">addedBehavior</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;ConcreteDecoratorA added behavior&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// ConcreteDecoratorB是另一个Decorator的具体实现，它也添加了额外的行为</span></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">ConcreteDecoratorB</span> <span class="token keyword">extends</span> <span class="token class-name">Decorator</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 构造方法，调用父类的构造方法</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">ConcreteDecoratorB</span><span class="token punctuation">(</span><span class="token class-name">Component</span> component<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">super</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// 重写operation方法，在调用被装饰对象的方法之后添加额外的行为</span></span>
<span class="line">    <span class="token annotation punctuation">@Override</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用被装饰对象的operation方法</span></span>
<span class="line">        <span class="token function">addedBehavior</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 添加额外的行为</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// 添加额外的行为</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">addedBehavior</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;ConcreteDecoratorB added behavior&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 客户端代码，使用装饰器模式</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DecoratorPatternDemo</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 创建一个ConcreteComponent对象</span></span>
<span class="line">        <span class="token class-name">Component</span> component <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        </span>
<span class="line">        <span class="token comment">// 使用ConcreteDecoratorA装饰ConcreteComponent</span></span>
<span class="line">        <span class="token class-name">Component</span> decoratorA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteDecoratorA</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        </span>
<span class="line">        <span class="token comment">// 使用ConcreteDecoratorB装饰ConcreteDecoratorA</span></span>
<span class="line">        <span class="token class-name">Component</span> decoratorB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteDecoratorB</span><span class="token punctuation">(</span>decoratorA<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// 执行operation方法，将会依次调用ConcreteComponent、ConcreteDecoratorA和ConcreteDecoratorB的operation方法</span></span>
<span class="line">        decoratorB<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container note"><p class="hint-container-title">注释</p><ul><li>在这个例子中，我们定义了一个组件接口<code>Component</code>和一个具体的组件实现<code>ConcreteComponent</code>。然后我们定义了一个装饰器抽象类<code>Decorator</code>，它实现了<code>Component</code>接口并持有一个<code>Component</code>对象的引用。<code>ConcreteDecoratorA</code>和<code>ConcreteDecoratorB</code>是两个具体的装饰器类，它们扩展了<code>Decorator</code>类并添加了额外的行为。</li><li>在客户端代码中，我们首先创建了一个<code>ConcreteComponent</code>对象，然后使用<code>ConcreteDecoratorA</code>和<code>ConcreteDecoratorB</code>对其进行装饰。当我们调用<code>decoratorB.operation()</code>时，它将依次执行<code>ConcreteComponent</code>、<code>ConcreteDecoratorA</code>和<code>ConcreteDecoratorB</code>的<code>operation</code>方法，从而实现了功能的动态添加。</li></ul></div>`,14)]))}const i=s(t,[["render",o]]),r=JSON.parse('{"path":"/software/DesignPattern-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F.html","title":"DesignPattern - 装饰器模式","lang":"zh-CN","frontmatter":{"title":"DesignPattern - 装饰器模式","author":"魔术桌","cover":"","category":["软件程序/设计模式"],"date":"2024-11-18T00:00:00.000Z","tag":["进度-已完成","知识总结"],"description":"文章摘要： 装饰器模式使用总结。 简介 简要说明 装饰器模式（Decorator Pattern）是一种结构型设计模式。 允许向一个现有的对象添加新的功能，同时又不改变其结构。 这种模式属于对象结构型模式，它是作为现有类的一个包装。 主要功能 在不改变接口的前提下，增强类的性能。 通过使用不同的具体装饰类以及这些装饰类的排列组合，可以实现不同的效果。 ...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"DesignPattern - 装饰器模式\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-11-18T00:00:00.000Z\\",\\"dateModified\\":\\"2025-10-03T09:56:57.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"魔术桌\\"}]}"],["meta",{"property":"og:url","content":"https://blog.magictable.ha.cn/software/DesignPattern-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F.html"}],["meta",{"property":"og:site_name","content":"魔术桌"}],["meta",{"property":"og:title","content":"DesignPattern - 装饰器模式"}],["meta",{"property":"og:description","content":"文章摘要： 装饰器模式使用总结。 简介 简要说明 装饰器模式（Decorator Pattern）是一种结构型设计模式。 允许向一个现有的对象添加新的功能，同时又不改变其结构。 这种模式属于对象结构型模式，它是作为现有类的一个包装。 主要功能 在不改变接口的前提下，增强类的性能。 通过使用不同的具体装饰类以及这些装饰类的排列组合，可以实现不同的效果。 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-03T09:56:57.000Z"}],["meta",{"property":"article:author","content":"魔术桌"}],["meta",{"property":"article:tag","content":"知识总结"}],["meta",{"property":"article:tag","content":"进度-已完成"}],["meta",{"property":"article:published_time","content":"2024-11-18T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-03T09:56:57.000Z"}]]},"git":{"updatedTime":1759485417000,"contributors":[{"name":"MagicTable-RedmiNote12TPro-Android","username":"","email":"13459588094@163.com","commits":1},{"name":"MagicTable-HappinessHome-DebianLinux","username":"","email":"13459588094@163.com","commits":2}],"changelog":[{"hash":"2f64e32c6bfa04fdb137fc5247de26e5603a0eb3","time":1759485417000,"email":"13459588094@163.com","author":"MagicTable-HappinessHome-DebianLinux","message":"vault backup: 2025-10-03 17:56:57"},{"hash":"ea490d819f6b9c38b6faf647221faa9808862172","time":1759413290000,"email":"13459588094@163.com","author":"MagicTable-HappinessHome-DebianLinux","message":"更新博客文章数据"},{"hash":"bd68b5c596d6a0543e6461d26edd64a5440f6020","time":1758421995000,"email":"13459588094@163.com","author":"MagicTable-RedmiNote12TPro-Android","message":"初始化仓库版本"}]},"autoDesc":true,"filePathRelative":"software/DesignPattern-装饰器模式.md","excerpt":"<p><strong>文章摘要：</strong> 装饰器模式使用总结。</p>\\n"}');export{i as comp,r as data};
