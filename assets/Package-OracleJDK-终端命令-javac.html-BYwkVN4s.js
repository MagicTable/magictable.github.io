import{_ as e,c as l,a as c,o}from"./app-D67BBu3k.js";const i={};function s(n,a){return o(),l("div",null,a[0]||(a[0]=[c(`<p><strong>文章摘要：</strong> 读取 Java 类和接口定义，并将它们编译为字节码和类文件。</p><h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h2><ul><li><code>javac</code> 命令读取用 Java 编程语言编写的类和接口定义，并将它们编译为字节码类文件。</li><li><code>javac</code> 命令还可以处理 Java 源文件和类中的注释。</li></ul><p>有两种方法可以将源代码文件名传递给 <code>javac</code>：</p><ul><li>对于少量源文件，请在命令行上列出文件名。</li><li>对于大量源文件，请在文件中列出文件名，并用空格或换行符分隔。在 <code>javac</code> 命令中使用前面带有 at 符号 （@） 的列表文件名。</li></ul><div class="hint-container note"><p class="hint-container-title">注释</p><ul><li>源代码文件名必须具有 .java 后缀，类文件名必须具有 .class 后缀，并且源文件和类文件都必须具有标识类的根名称。例如，名为 <code>MyClass</code> 的类将写入名为 <code>MyClass.java</code> 的源文件中，并编译为名为 <code>MyClass.class</code> 的字节码类文件。</li><li>内部类定义会生成其他类文件。这些类文件具有由内部和外部类名组合而成的名称，例如 <code>MyClass$MyInnerClass.class</code>。</li><li>将源文件排列在反映其包树的目录树中。例如，如果所有源文件都位于 <code>/workspace</code> 中，则将 <code>com.mysoft.mypack.MyClass</code> 的源代码放在 <code>/workspace/com/mysoft/mypack/MyClass.java</code> 。</li><li>默认情况下，编译器将每个类文件放在与其源文件相同的目录中。您可以使用 <code>-d</code> 选项指定单独的目标目录。</li></ul></div><h2 id="格式" tabindex="-1"><a class="header-anchor" href="#格式"><span>格式</span></a></h2><div class="hint-container tip"><p class="hint-container-title">提示</p><p><code>javac [&lt;选项&gt;] [&lt;源文件&gt;] [&lt;类&gt;] [@argfiles]</code></p></div><h3 id="选项" tabindex="-1"><a class="header-anchor" href="#选项"><span>选项</span></a></h3><div class="hint-container note"><p class="hint-container-title">注释</p><p><strong>标准选项</strong></p><ul><li>编译器具有一组在当前开发环境中受支持的标准选项。</li><li>另一组非标准选项特定于当前虚拟机和编译器实现，将来可能会更改。</li><li>非标准选项以 <code>-X</code> 选项开头。</li></ul></div><p><code>-help</code></p><ul><li>打印标准选项的概要。</li></ul><p><code>-A &lt;键&gt;[=&lt;值&gt;]</code></p><ul><li>指定要传递给注释处理器的选项。这些选项不是由 <code>javac</code> 直接解释的，而是可供各个处理器使用。<code>键</code>值应为一个或多个标识符，用点 （.） 分隔。</li></ul><p><code>-cp path</code> <code>-classpath path</code></p><ul><li>指定查找用户类文件以及 （可选） 注释处理器和源文件的位置。</li><li>此类路径将覆盖 <code>CLASSPATH</code> 环境变量中的用户类路径。</li><li>如果 <code>CLASSPATH</code>、<code>-cp</code> 和 <code>-classpath</code> 均未指定，则用户_类路径_为当前目录。</li><li>如果未指定 <code>-sourcepath</code> 选项，则还会在用户类路径中搜索源文件。</li><li>如果未指定 <code>-processorpath</code> 选项，则还会在类路径中搜索 annotation 处理器。</li></ul><p><code>-Djava.ext.dirs=&lt;目录&gt;</code></p><ul><li>覆盖已安装扩展的位置。</li></ul><p><code>-Djava.endorsed.dirs=&lt;目录&gt;</code></p><ul><li>覆盖已认可的标准路径的位置。</li></ul><p><code>-d &lt;目录&gt;</code></p><ul><li>设置类文件的目标目录。该目录必须已存在，因为 <code>javac</code> 不会创建该目录。</li><li>如果类是包的一部分，则 <code>javac</code> 会将类文件放在反映包名称的子目录中，并根据需要创建目录。</li><li>例如：指定 <code>-d /home/myclasses</code>，并且类名为 <code>com.mypackage.MyClass</code>，则类文件为 <code>/home/myclasses/com/mypackage/MyClass.class</code>。</li><li>例如：未指定 <code>-d</code> 选项，则 <code>javac</code> 会将每个类文件放在与生成该类文件的源文件相同的目录中。</li><li><strong>注意</strong>：<code>-d</code> 选项指定的目录不会自动添加到您的用户类路径中。</li></ul><p><code>-deprecation</code></p><ul><li>显示已弃用成员或类的每次使用或重写的说明。如果没有 <code>-deprecation</code> 选项，<code>javac</code> 将显示使用或覆盖不推荐使用的成员或类的源文件的摘要。</li><li><code>-deprecation</code> 选项是 <code>-Xlint：deprecation</code> 的简写。</li></ul><p><code>-encoding &lt;编码&gt;</code></p><ul><li>设置源文件编码名称。</li><li>如果未指定 <code>-encoding</code> 选项，则使用平台默认转换器。</li><li>编码：UTF-8</li></ul><p><code>-endorseddirs &lt;目录&gt;</code></p><ul><li>覆盖已认可的标准路径的位置。</li></ul><p><code>-extdirs &lt;目录&gt;</code></p><ul><li>覆盖 <code>ext</code> 目录的位置。directories 变量是以冒号分隔的目录列表。将搜索指定目录中的每个 JAR 文件以查找类文件。找到的所有 JAR 文件都将成为类路径的一部分。</li></ul><p><code>-g</code></p><ul><li>生成所有调试信息，包括局部变量。</li><li>默认情况下，仅生成行号和源文件信息。</li></ul><p><code>-g:none</code></p><ul><li>不生成任何调试信息。</li></ul><p><code>-g:[&lt;关键字列表&gt;]</code></p><ul><li>仅生成某些类型的调试信息，由逗号分隔的关键字列表指定。</li><li><strong>关键字列表</strong>：<code>source</code>源文件调试信息，<code>lines</code>行号调试信息，<code>vars</code>局部变量调试信息。</li></ul><p><code>-implicit:[&lt;选项&gt;]</code></p><ul><li>控制隐式加载的源文件的类文件的生成。</li><li><strong>选项</strong>：<code>class</code>要自动生成类文件，<code>none</code>要禁止生成类文件。</li><li>如果未指定此选项，则默认为 automatically generate class files。在这种情况下，如果在执行注释处理时生成任何此类类文件，编译器会发出警告。</li><li>当显式设置 <code>-implicit</code> 选项时，不会发出警告。</li></ul><p><code>-J&lt;选项&gt;</code></p><ul><li>将<code>选项</code>传递给 Java 虚拟机（JVM），其中<code>选项</code>是 Java 启动器参考页面上描述的选项之一。</li><li>例如，<code>-J-Xms48m</code> 将启动内存设置为 48 MB。</li></ul><p><code>-nowarn</code></p><ul><li>禁用警告消息。</li><li>此选项的操作与 <code>-Xlint：none</code> 选项相同。</li></ul><p><code>-parameters</code></p><ul><li>将构造函数和方法的形参名称存储在生成的类文件中，以便 Reflection API 中的方法可以 <code>java.lang.reflect.Executable.getParameters</code> 检索它们。</li></ul><p><code>-proc: [&lt;选项&gt;]</code></p><ul><li>控制是否完成注释处理和编译。</li><li><strong>选项</strong>：<code>none</code>表示编译时不进行Comments处理，<code>only</code>表示仅完成Comments处理不进行任何后续编译。</li></ul><p><code>-processor class1 [,class2,class3...]</code></p><ul><li>要运行的注释处理器的名称。这将绕过默认的发现过程。</li></ul><p><code>-processorpath &lt;路径&gt;</code></p><ul><li>指定查找注释处理器的位置。</li><li>如果未使用此选项，则在类路径中搜索处理器。</li></ul><p><code>-s &lt;目录&gt;</code></p><ul><li>指定放置生成的源文件的目录。</li><li>该目录必须已存在，因为 <code>javac</code> 不会创建该目录。</li><li>如果类是包的一部分，则编译器会将源文件放在反映包名称的子目录中，并根据需要创建目录。</li></ul><p><code>-source &lt;版本&gt;</code></p><ul><li>指定接受的源代码版本。</li><li>版本：</li><li><code>1.3</code>：编译器不支持断言、泛型或 Java SE 1.3 之后引入的其他语言功能。</li><li><code>1.4</code>：编译器接受包含 Java SE 1.4 中引入的断言的代码。</li><li><code>1.5</code>：编译器接受包含 Java SE 5 中引入的泛型和其他语言功能的代码。</li><li><code>5</code>：Synonym for 1.5. 1.5 的同义词。</li><li><code>1.6</code>：Java SE 6 中没有引入任何语言更改。但是，源文件中的编码错误现在报告为错误，而不是像 Java Platform， Standard Edition 的早期发行版那样报告为警告。</li><li><code>6</code>：Synonym for 1.6. 1.6 的同义词。</li><li><code>1.7</code>：编译器接受具有 Java SE 7 中引入的功能的代码。</li><li><code>7</code>：Synonym for 1.7. 1.7 的同义词。</li><li><code>1.8</code>：这是默认值。编译器接受具有 Java SE 8 中引入的功能的代码。</li><li><code>8</code>：Synonym for 1.8. 1.8 的同义词。</li></ul><p><code>-sourcepath &lt;源路径&gt;</code></p><ul><li>指定用于搜索类或接口定义的源代码路径。</li><li>与用户类路径一样，源路径条目在上下文中用冒号（:)在 Oracle Solaris 上和分号之间分隔，可以是目录、JAR 存档或 ZIP 存档。如果使用 packages，则目录或存档中的本地路径名必须反映 package 名称。</li></ul><p><code>-verbose</code></p><ul><li>使用详细输出，其中包括有关加载的每个类和编译的每个源文件的信息。</li></ul><p><code>-version</code></p><ul><li>打印版本信息。</li></ul><p><code>-werror</code></p><ul><li>出现警告时终止编译。</li></ul><p><code>-X</code></p><ul><li>显示有关非标准选项和退出的信息。</li></ul><div class="hint-container note"><p class="hint-container-title">注释</p><p><strong>交叉编译选项</strong></p><ul><li>默认情况下，类是根据 <code>javac</code> 附带的平台的引导类和扩展类进行编译的。</li><li>但 <code>javac</code> 也支持交叉编译，其中类是针对不同 Java 平台实现的引导和扩展类进行编译的。</li><li>在交叉编译时使用 <code>-bootclasspath</code> 和 <code>-extdirs</code> 选项非常重要。</li></ul></div><p><code>-target &lt;版本&gt;</code></p><ul><li>生成以虚拟机的指定版本为目标的类文件。</li><li>类文件将在指定的目标和更高版本上运行，但不在 JVM 的早期版本上运行。有效目标是 1.1、1.2、1.3、1.4、1.5（也是 5）、1.6（也是 6）、1.7（也是 7）和 1.8（也是 8）。</li></ul><p><code>-bootclasspath &lt;引导类路径&gt;</code></p><ul><li>针对指定的引导类集进行交叉编译。与用户类路径一样，引导类路径条目由冒号 （:)分隔，可以是目录、JAR 存档或 ZIP 存档。</li></ul><p><code>-profile</code></p><ul><li>使用压缩配置文件时，此选项在编译时指定配置文件名称。例如：<code>javac -profile compact1 Hello.java</code></li></ul><h3 id="源文件" tabindex="-1"><a class="header-anchor" href="#源文件"><span>源文件</span></a></h3><ul><li>要编译的一个或多个源文件（例如 <code>MyClass.java</code>）。</li></ul><h3 id="类" tabindex="-1"><a class="header-anchor" href="#类"><span>类</span></a></h3><ul><li>要处理注释的一个或多个类（例如 <code>MyPackage.MyClass</code>）。</li></ul><h3 id="argfiles" tabindex="-1"><a class="header-anchor" href="#argfiles"><span>@argfiles</span></a></h3><ul><li>列出选项和源文件的一个或多个文件。这些文件不允许使用 <code>-J</code> 选项。</li></ul><h2 id="案例" tabindex="-1"><a class="header-anchor" href="#案例"><span>案例</span></a></h2><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line"><span class="token comment"># 编译多个源文件</span></span>
<span class="line">javac Main.java Helper.java</span>
<span class="line"></span>
<span class="line"><span class="token comment"># 指定类路径</span></span>
<span class="line">javac <span class="token parameter variable">-cp</span> /usr/lib/java/commons.jar:. MyClass.java</span>
<span class="line"></span>
<span class="line"><span class="token comment"># 指定输出目录</span></span>
<span class="line">javac <span class="token parameter variable">-d</span> ./bin MyClass.java</span>
<span class="line"></span>
<span class="line"><span class="token comment"># 包含调试信息</span></span>
<span class="line">javac <span class="token parameter variable">-g</span> MyClass.java</span>
<span class="line"></span>
<span class="line"><span class="token comment"># 忽略警告</span></span>
<span class="line">javac <span class="token parameter variable">-nowarn</span> MyClass.java</span>
<span class="line"></span>
<span class="line"><span class="token comment"># 显示详细信息</span></span>
<span class="line">javac <span class="token parameter variable">-verbose</span> MyClass.java</span>
<span class="line"></span>
<span class="line"><span class="token comment"># 使用源路径</span></span>
<span class="line">javac <span class="token parameter variable">-sourcepath</span> /usr/src/java MyClass.java</span>
<span class="line"></span>
<span class="line"><span class="token comment"># 使用不同的java版本</span></span>
<span class="line">javac <span class="token parameter variable">-source</span> <span class="token number">1.7</span> <span class="token parameter variable">-target</span> <span class="token number">1.7</span> MyClass.java</span>
<span class="line"></span>
<span class="line"><span class="token comment"># 编译注释处理程序</span></span>
<span class="line">javac <span class="token parameter variable">-processor</span> com.example.MyProcessor MyClass.java</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="使用-xlint选项启用或禁用警告" tabindex="-1"><a class="header-anchor" href="#使用-xlint选项启用或禁用警告"><span>使用<code>-Xlint</code>选项启用或禁用警告</span></a></h2><p>使用 <code>-Xlint：name</code> 选项启用警告_名称_，其中 <code>name</code> 是以下警告名称之一。请注意，您可以使用 <code>-Xlint：-name：</code> 选项禁用警告。</p><p><code>cast</code></p><ul><li>对不必要和冗余的强制转换发出警告。</li></ul><p><code>classfile</code></p><ul><li>警告与类文件内容相关的问题。</li></ul><p><code>deprecation</code></p><ul><li>对已弃用项目和API的使用发出警告。</li></ul><p><code>dep-ann</code></p><ul><li>对使用 <code>@deprecated</code> Javadoc 注释记录但没有 <code>@Deprecated</code> 注释的项目发出警告。</li></ul><p><code>divzero</code></p><ul><li>对常数整数 0 的除法发出警告。</li></ul><p><code>empty</code></p><ul><li>对 <code>if</code> 语句之后的空语句发出警告。</li></ul><p><code>fallthrough</code></p><ul><li>检查 switch 块中是否存在直通情况，并为找到的任何情况提供警告消息。</li><li>Fall-through case 是 switch 块中的情况，而不是块中的最后一个 case，其代码不包含 break 语句，从而允许代码执行从该 case 过渡到下一个 case。</li><li>如果在编译此代码时使用 <code>-Xlint：fallthrough</code> 选项，则编译器会发出有关可能 fallthrough into case 的警告，并提供相关 case 的行号。</li></ul><p><code>finally</code></p><ul><li>对无法正常完成的 <code>finally</code> 子句发出警告。</li></ul><p><code>options</code></p><ul><li>对与使用命令行选项相关的问题发出警告。</li></ul><p><code>overrides</code></p><ul><li>对有关方法覆盖的问题发出警告。</li></ul><p><code>path</code></p><ul><li>对命令行上的无效路径元素和不存在的路径目录（关于类路径、源路径和其他路径）发出警告。</li></ul><p><code>processing</code></p><ul><li>警告有关注释处理的问题。</li><li>当您有一个具有注释的类，并且您使用的注释处理器无法处理该类型的异常时，编译器将生成此警告。</li></ul><p><code>rawtypes</code></p><ul><li>对原始类型执行未经检查的操作时发出警告。</li></ul><p><code>Serial</code></p><ul><li>警告可序列化类上缺少 <code>serialVersionUID</code> 定义。</li></ul><p><code>static</code></p><ul><li>对与使用静态力学相关的问题发出警告。</li></ul><p><code>try</code></p><ul><li>警告与使用 <code>try</code> 块相关的问题，包括 try-with-resources 语句。</li></ul><p><code>unchecked</code></p><ul><li>提供 Java 语言规范强制要求的未选中的转换警告的更多详细信息。</li></ul><p><code>varargs</code></p><ul><li>警告变量参数 （<code>varargs</code>） 方法的不安全使用，特别是那些包含不可修改参数的方法。</li></ul><h2 id="命令行参数文件" tabindex="-1"><a class="header-anchor" href="#命令行参数文件"><span>命令行参数文件</span></a></h2><p>命令行参数文件是用于简化 <code>javac</code> 命令的工具，允许开发者将 <code>javac</code> 的参数列表放入一个或多个文件中，而不是直接在命令行中输入。以下是关于命令行参数文件的总结：</p><ul><li><strong>目的</strong>：简化长或复杂的 <code>javac</code> 命令，使其更易于管理和执行。</li><li><strong>内容</strong>：参数文件可以包含 <code>javac</code> 的选项和源文件名，但不能包含 <code>-J</code> 选项。</li><li><strong>格式</strong>：参数文件中的参数可以用空格或换行符分隔。如果文件名包含空格，需要用双引号括起来。</li><li><strong>路径</strong>：参数文件中的文件名是相对于当前工作目录的，而不是参数文件的位置。不支持使用通配符和递归解释文件。</li><li><strong>使用方法</strong>：在 <code>javac</code> 命令中，通过在参数文件名前加上 <code>@</code> 符号来引用参数文件。</li><li><strong>示例</strong>： <ul><li>单个参数文件：<code>javac @argfile</code></li><li>多个参数文件：分别创建选项文件（如 <code>options</code>）和源文件列表（如 <code>classes</code>），然后使用 <code>javac @options @classes</code> 来编译。</li><li>带路径的参数文件：参数文件可以位于任意路径，但文件内的路径是相对于当前工作目录的。</li></ul></li></ul><h2 id="注释处理" tabindex="-1"><a class="header-anchor" href="#注释处理"><span>注释处理</span></a></h2><p>注释处理是 Java 编译器 <code>javac</code> 的一个特性，它允许在编译过程中检测和处理源代码中的注释。以下是关于注释处理的总结：</p><ul><li><strong>集成</strong>：<code>javac</code> 直接支持注释处理，无需使用单独的命令 <code>apt</code>。</li><li><strong>API 定义</strong>：注释处理器的 API 位于 <code>javax.annotation.processing</code> 和 <code>javax.lang.model</code> 包及其子包中。</li><li><strong>工作原理</strong>： <ul><li>除非使用 <code>-proc:none</code> 禁用，编译器会搜索可用的注释处理器。</li><li>可以通过 <code>-processorpath</code> 指定搜索路径，默认使用用户类路径。</li><li>注释处理器通过 <code>META-INF/services/javax.annotation.processing.Processor</code> 配置文件发现。</li><li>可以通过 <code>-processor</code> 显式指定处理器。</li></ul></li><li><strong>处理流程</strong>： <ul><li>编译器扫描源文件和类以查找注释。</li><li>匹配的注释由相应的处理器处理。</li><li>处理器可以声明它们处理的注释，防止其他处理器处理相同的注释。</li><li>如果处理器生成新的源文件，将启动新一轮的注释处理。</li><li>处理过程重复，直到不再生成新的源文件。</li><li>最后，处理器被最后一次调用以完成剩余工作，然后编译器编译所有源文件，除非使用 <code>-proc:only</code>。</li></ul></li><li><strong>隐式加载的源文件</strong>： <ul><li>编译器可能需要隐式加载额外的源文件来编译指定的源文件集。</li><li>这些隐式加载的源文件目前不受注释处理的影响。</li><li>默认情况下，如果注释处理发生且编译了隐式加载的源文件，编译器会发出警告。</li><li>使用 <code>-implicit</code> 选项可以抑制该警告。</li></ul></li></ul><h2 id="搜索类型" tabindex="-1"><a class="header-anchor" href="#搜索类型"><span>搜索类型</span></a></h2><p>在编译 Java 源文件时，编译器需要查找和使用各种类型的信息，以下是对类型搜索过程的总结：</p><p>类型信息需求</p><ul><li>编译器需要了解源文件中使用、扩展或实现的每个类或接口，包括通过继承引入但未在源文件中直接提及的类型。</li></ul><p>搜索过程</p><ul><li>编译器首先在引导类和扩展类中搜索类文件。</li><li>然后编译器在用户类路径中搜索类文件，用户类路径默认为当前目录，可以通过设置 CLASSPATH 环境变量或使用 -classpath 选项来定义。</li><li>如果设置了 -sourcepath 选项，编译器会在指定的路径中搜索源文件；否则，编译器会在用户类路径中同时搜索类文件和源文件。</li></ul><p>引导和扩展类路径</p><ul><li>可以使用 -bootclasspath 和 -extdirs 选项来指定不同的引导或扩展类路径。</li></ul><p>搜索结果</p><ul><li>类型搜索可能找到类文件、源文件或两者都有。</li><li>使用 -Xprefer 选项可以指定编译器在找到两者时使用哪个文件（newer 或 source），默认为 newer。</li></ul><p>源文件处理</p><ul><li>如果找到了源文件，编译器会读取它以获取所需信息，并默认编译该源文件。</li><li>-implicit 选项可以用来指定是否为找到的源文件生成类文件，默认情况下不会生成。</li></ul><p>注释处理和警告</p><ul><li>编译器可能在注释处理完成后才意识到某些类型信息的需求。</li><li>如果在源文件中找到类型信息且未指定 -implicit 选项，编译器会发出警告，指出该文件正在编译但未受注释处理。</li><li>要禁用警告，可以在命令行上显式指定文件或使用 -implicit 选项。</li></ul><h2 id="编程接口" tabindex="-1"><a class="header-anchor" href="#编程接口"><span>编程接口</span></a></h2><p>Java 编译器 <code>javac</code> 提供了编程接口，允许开发者以编程方式调用编译器，而不是通过命令行。</p><h3 id="新-java-编译器-api-javax-tools" tabindex="-1"><a class="header-anchor" href="#新-java-编译器-api-javax-tools"><span>新 Java 编译器 API (<code>javax.tools</code>)</span></a></h3><ul><li><strong>支持</strong>：<code>javac</code> 命令支持由 <code>javax.tools</code> 包中的类和接口定义的新 Java 编译器 API。</li><li><strong>示例</strong>：以下是如何使用新 API 进行编译的示例：</li></ul><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token class-name">JavaCompiler</span> javac <span class="token operator">=</span> <span class="token class-name">ToolProvider</span><span class="token punctuation">.</span><span class="token function">getSystemJavaCompiler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// 这个示例将诊断信息写入标准输出流，并返回与命令行调用 \`javac\` 时相同的退出代码。</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>功能</strong>：可以通过 <code>javax.tools.JavaCompiler</code> 接口中的其他方法来处理诊断信息、控制文件的读写位置等。</li></ul><h3 id="旧接口-com-sun-tools-javac-main" tabindex="-1"><a class="header-anchor" href="#旧接口-com-sun-tools-javac-main"><span>旧接口 (<code>com.sun.tools.javac.Main</code>)</span></a></h3><ul><li><strong>向后兼容</strong>：保留此 API 仅用于向后兼容。推荐新代码使用 <code>javax.tools</code> 中的新 Java 编译器 API。</li><li><strong>方法</strong>：<code>com.sun.tools.javac.Main</code> 类提供了两种静态方法来从程序中调用编译器： <ul><li><code>public static int compile(String[] args);</code></li><li><code>public static int compile(String[] args, PrintWriter out);</code></li></ul></li><li><strong>参数</strong>： <ul><li><code>args</code>：表示传递给编译器的命令行参数。</li><li><code>out</code>：指定编译器诊断输出的位置。</li></ul></li><li><strong>返回值</strong>：返回值等同于命令行调用 <code>javac</code> 的退出值。</li><li><strong>内部类和方法</strong>：以 <code>com.sun.tools.javac</code> 开头的包（及其子包）中的其他类和方法是内部的，可能会随时更改，不应在应用程序代码中使用。</li></ul>`,145)]))}const t=e(i,[["render",s]]),p=JSON.parse('{"path":"/software/Package-OracleJDK-%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4-javac.html","title":"Package - OracleJDK - 终端命令 - javac","lang":"zh-CN","frontmatter":{"title":"Package - OracleJDK - 终端命令 - javac","author":"魔术桌","cover":"","category":["软件程序/软件包"],"date":"2024-12-28T00:00:00.000Z","tag":["进度-已完成","查询手册"],"description":"文章摘要： 读取 Java 类和接口定义，并将它们编译为字节码和类文件。 简介 javac 命令读取用 Java 编程语言编写的类和接口定义，并将它们编译为字节码类文件。 javac 命令还可以处理 Java 源文件和类中的注释。 有两种方法可以将源代码文件名传递给 javac： 对于少量源文件，请在命令行上列出文件名。 对于大量源文件，请在文件中列出...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Package - OracleJDK - 终端命令 - javac\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-12-28T00:00:00.000Z\\",\\"dateModified\\":\\"2025-10-06T02:37:54.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"魔术桌\\"}]}"],["meta",{"property":"og:url","content":"https://blog.magictable.ha.cn/software/Package-OracleJDK-%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4-javac.html"}],["meta",{"property":"og:site_name","content":"魔术桌"}],["meta",{"property":"og:title","content":"Package - OracleJDK - 终端命令 - javac"}],["meta",{"property":"og:description","content":"文章摘要： 读取 Java 类和接口定义，并将它们编译为字节码和类文件。 简介 javac 命令读取用 Java 编程语言编写的类和接口定义，并将它们编译为字节码类文件。 javac 命令还可以处理 Java 源文件和类中的注释。 有两种方法可以将源代码文件名传递给 javac： 对于少量源文件，请在命令行上列出文件名。 对于大量源文件，请在文件中列出..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-06T02:37:54.000Z"}],["meta",{"property":"article:author","content":"魔术桌"}],["meta",{"property":"article:tag","content":"查询手册"}],["meta",{"property":"article:tag","content":"进度-已完成"}],["meta",{"property":"article:published_time","content":"2024-12-28T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-06T02:37:54.000Z"}]]},"git":{"updatedTime":1759718274000,"contributors":[{"name":"MagicTable-RedmiNote12TPro-Android","username":"","email":"13459588094@163.com","commits":2},{"name":"MagicTable-HappinessHome-DebianLinux","username":"","email":"13459588094@163.com","commits":1}],"changelog":[{"hash":"2fee46a18beafc4284ad1e19b3f2684c7954037e","time":1759718274000,"email":"13459588094@163.com","author":"MagicTable-RedmiNote12TPro-Android","message":"手机端同步笔记"},{"hash":"ea490d819f6b9c38b6faf647221faa9808862172","time":1759413290000,"email":"13459588094@163.com","author":"MagicTable-HappinessHome-DebianLinux","message":"更新博客文章数据"},{"hash":"bd68b5c596d6a0543e6461d26edd64a5440f6020","time":1758421995000,"email":"13459588094@163.com","author":"MagicTable-RedmiNote12TPro-Android","message":"初始化仓库版本"}]},"autoDesc":true,"filePathRelative":"software/Package-OracleJDK-终端命令-javac.md","excerpt":"<p><strong>文章摘要：</strong> 读取 Java 类和接口定义，并将它们编译为字节码和类文件。</p>\\n"}');export{t as comp,p as data};
