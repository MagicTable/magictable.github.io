import{_ as e,c as a,a as s,b as t,d as n,e as i,w as r,r as u,o as E}from"./app-D67BBu3k.js";const p={};function m(d,l){const o=u("RouteLink");return E(),a("div",null,[l[22]||(l[22]=s('<p><strong>文章摘要：</strong> 将一组数据按照特定的顺序排列的算法。</p><h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h2><p>简要说明</p><ul><li>将一组数据按照特定的顺序排列。</li></ul><p>主要功能</p><ul><li>将数据元素按照预定的顺序（如升序或降序）重新排列。</li><li>提高数据的查找和访问效率。</li><li>为其他算法（如搜索和合并操作）提供预处理步骤。</li></ul><p>注意事项</p><ul><li>算法的时间复杂度和空间复杂度：选择适合数据规模和性能要求的排序算法。</li><li>稳定性：如果需要保持相同元素的相对顺序，应选择稳定排序算法。</li><li>外部排序与内部排序：对于无法全部加载到内存中的大数据集，需要使用外部排序。</li></ul><p>适用场景</p><ul><li><p><strong>内部排序</strong>：数据量较小，可以全部加载到内存中的情况。</p><ul><li><strong>插入排序</strong>：适用于小规模或部分有序的数据。</li><li><strong>快速排序</strong>：适用于大规模数据，平均性能较好。</li></ul></li><li><p><strong>外部排序</strong>：数据量较大，无法全部加载到内存中的情况。</p><ul><li><strong>归并排序</strong>：适用于外部排序，因为其稳定的性质和易于并行化的特点。</li></ul></li></ul><h2 id="冒泡排序" tabindex="-1"><a class="header-anchor" href="#冒泡排序"><span>冒泡排序</span></a></h2><ul><li>通过重复遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。</li><li>遍历数列的工作是重复地进行，直到没有再需要交换的元素为止。</li></ul>',12)),t("p",null,[l[1]||(l[1]=n("详细总结：")),i(o,{to:"/software/Algorithm-%E6%8E%92%E5%BA%8F-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.html"},{default:r(()=>l[0]||(l[0]=[n("冒泡排序")])),_:1,__:[0]})]),l[23]||(l[23]=t("h2",{id:"选择排序",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#选择排序"},[t("span",null,"选择排序")])],-1)),l[24]||(l[24]=t("ul",null,[t("li",null,"选择排序（Selection Sort）。"),t("li",null,"工作原理是首先在未排序序列中找到最小（或最大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（或最大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。")],-1)),t("p",null,[l[3]||(l[3]=n("详细总结：")),i(o,{to:"/software/Algorithm-%E6%8E%92%E5%BA%8F-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.html"},{default:r(()=>l[2]||(l[2]=[n("选择排序")])),_:1,__:[2]})]),l[25]||(l[25]=t("h2",{id:"插入排序",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#插入排序"},[t("span",null,"插入排序")])],-1)),l[26]||(l[26]=t("ul",null,[t("li",null,"通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。"),t("li",null,"插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序）。")],-1)),t("p",null,[l[5]||(l[5]=n("详细总结：")),i(o,{to:"/software/Algorithm-%E6%8E%92%E5%BA%8F-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.html"},{default:r(()=>l[4]||(l[4]=[n("插入排序")])),_:1,__:[4]})]),l[27]||(l[27]=t("h2",{id:"快速排序",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#快速排序"},[t("span",null,"快速排序")])],-1)),l[28]||(l[28]=t("ul",null,[t("li",null,"快速排序是一种高效的排序算法，采用分治法的一个典例。"),t("li",null,"通过选取一个“基准”元素，将数组分为两个子数组，一个包含小于基准的元素，另一个包含大于基准的元素，然后递归地对这两个子数组进行快速排序。")],-1)),t("p",null,[l[7]||(l[7]=n("详细总结：")),i(o,{to:"/software/Algorithm-%E6%8E%92%E5%BA%8F-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html"},{default:r(()=>l[6]||(l[6]=[n("快速排序")])),_:1,__:[6]})]),l[29]||(l[29]=t("h2",{id:"归并排序",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#归并排序"},[t("span",null,"归并排序")])],-1)),l[30]||(l[30]=t("ul",null,[t("li",null,"归并排序是一种分治算法。"),t("li",null,"将数组分成两半，分别对它们进行排序，然后将排序好的两部分合并在一起。这个过程递归地进行，直到每个子部分只有一个位置，然后开始合并。")],-1)),t("p",null,[l[9]||(l[9]=n("详细总结：")),i(o,{to:"/software/Algorithm-%E6%8E%92%E5%BA%8F-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.html"},{default:r(()=>l[8]||(l[8]=[n("归并排序")])),_:1,__:[8]})]),l[31]||(l[31]=t("h2",{id:"堆排序",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#堆排序"},[t("span",null,"堆排序")])],-1)),l[32]||(l[32]=t("ul",null,[t("li",null,"堆排序是一种基于比较的排序算法，利用堆这种数据结构进行排序。"),t("li",null,"堆是一种近似完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或者大于）它的父节点。")],-1)),t("p",null,[l[11]||(l[11]=n("详细总结：")),i(o,{to:"/software/Algorithm-%E6%8E%92%E5%BA%8F-%E5%A0%86%E6%8E%92%E5%BA%8F.html"},{default:r(()=>l[10]||(l[10]=[n("堆排序")])),_:1,__:[10]})]),l[33]||(l[33]=t("h2",{id:"希尔排序",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#希尔排序"},[t("span",null,"希尔排序")])],-1)),l[34]||(l[34]=t("ul",null,[t("li",null,"希尔排序是插入排序的一种更高效的改进版本。"),t("li",null,"通过比较距离较远的数据来工作，其核心理念是使数组中任意间隔为h的元素都是有序的。"),t("li",null,"希尔排序也称递减增量排序，因为它会优先比较距离较远的元素。")],-1)),t("p",null,[l[13]||(l[13]=n("详细总结：")),i(o,{to:"/software/Algorithm-%E6%8E%92%E5%BA%8F-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.html"},{default:r(()=>l[12]||(l[12]=[n("希尔排序")])),_:1,__:[12]})]),l[35]||(l[35]=t("h2",{id:"计数排序",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#计数排序"},[t("span",null,"计数排序")])],-1)),l[36]||(l[36]=t("ul",null,[t("li",null,"计数排序是一种非比较型整数排序算法。"),t("li",null,"使用一个额外的数组来计算每个元素的出现次数，然后根据计数数组来将元素放到正确的位置。计数排序适用于小范围整数的排序。")],-1)),t("p",null,[l[15]||(l[15]=n("详细总结：")),i(o,{to:"/software/Algorithm-%E6%8E%92%E5%BA%8F-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.html"},{default:r(()=>l[14]||(l[14]=[n("计数排序")])),_:1,__:[14]})]),l[37]||(l[37]=t("h2",{id:"基数排序",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#基数排序"},[t("span",null,"基数排序")])],-1)),l[38]||(l[38]=t("ul",null,[t("li",null,"基数排序是一种非比较型整数排序算法。"),t("li",null,"将整数按位数切割成不同的数字，然后按每个位数进行比较排序。排序过程是通过分配和收集来完成的，其中分配是将数字按照某位的大小放入桶中，收集是将桶中的数字再放回原数组。")],-1)),t("p",null,[l[17]||(l[17]=n("详细总结：")),i(o,{to:"/software/Algorithm-%E6%8E%92%E5%BA%8F-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.html"},{default:r(()=>l[16]||(l[16]=[n("基数排序")])),_:1,__:[16]})]),l[39]||(l[39]=t("h2",{id:"桶排序",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#桶排序"},[t("span",null,"桶排序")])],-1)),l[40]||(l[40]=t("ul",null,[t("li",null,"桶排序是一种将待排序数据分到几个有序的桶里，每个桶里的数据再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后将各桶的数据合并成有序数列的排序算法。")],-1)),t("p",null,[l[19]||(l[19]=n("详细总结：")),i(o,{to:"/software/Algorithm-%E6%8E%92%E5%BA%8F-%E6%A1%B6%E6%8E%92%E5%BA%8F.html"},{default:r(()=>l[18]||(l[18]=[n("桶排序")])),_:1,__:[18]})]),l[41]||(l[41]=t("h2",{id:"二叉树排序",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#二叉树排序"},[t("span",null,"二叉树排序")])],-1)),l[42]||(l[42]=t("ul",null,[t("li",null,"二叉树排序算法通常指的是通过构建一棵二叉搜索树（BST）来进行排序。在这种方法中，数据元素被插入到二叉搜索树中，树的每个节点都遵循左子树小于父节点，右子树大于父节点的规则。"),t("li",null,"排序过程是通过中序遍历这棵树来完成的，因为中序遍历会按照升序访问所有节点。")],-1)),t("p",null,[l[21]||(l[21]=n("详细总结：")),i(o,{to:"/software/Algorithm-%E6%8E%92%E5%BA%8F-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8E%92%E5%BA%8F.html"},{default:r(()=>l[20]||(l[20]=[n("二叉树排序")])),_:1,__:[20]})])])}const A=e(p,[["render",m]]),f=JSON.parse('{"path":"/software/Algorithm-%E6%8E%92%E5%BA%8F.html","title":"Algorithm - 排序","lang":"zh-CN","frontmatter":{"title":"Algorithm - 排序","author":"魔术桌","cover":"","category":["软件程序/算法设计"],"date":"2024-12-10T00:00:00.000Z","tag":["进度-已完成","知识总结"],"description":"文章摘要： 将一组数据按照特定的顺序排列的算法。 简介 简要说明 将一组数据按照特定的顺序排列。 主要功能 将数据元素按照预定的顺序（如升序或降序）重新排列。 提高数据的查找和访问效率。 为其他算法（如搜索和合并操作）提供预处理步骤。 注意事项 算法的时间复杂度和空间复杂度：选择适合数据规模和性能要求的排序算法。 稳定性：如果需要保持相同元素的相对顺序...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Algorithm - 排序\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-12-10T00:00:00.000Z\\",\\"dateModified\\":\\"2025-10-02T13:54:50.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"魔术桌\\"}]}"],["meta",{"property":"og:url","content":"https://blog.magictable.ha.cn/software/Algorithm-%E6%8E%92%E5%BA%8F.html"}],["meta",{"property":"og:site_name","content":"魔术桌"}],["meta",{"property":"og:title","content":"Algorithm - 排序"}],["meta",{"property":"og:description","content":"文章摘要： 将一组数据按照特定的顺序排列的算法。 简介 简要说明 将一组数据按照特定的顺序排列。 主要功能 将数据元素按照预定的顺序（如升序或降序）重新排列。 提高数据的查找和访问效率。 为其他算法（如搜索和合并操作）提供预处理步骤。 注意事项 算法的时间复杂度和空间复杂度：选择适合数据规模和性能要求的排序算法。 稳定性：如果需要保持相同元素的相对顺序..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-02T13:54:50.000Z"}],["meta",{"property":"article:author","content":"魔术桌"}],["meta",{"property":"article:tag","content":"知识总结"}],["meta",{"property":"article:tag","content":"进度-已完成"}],["meta",{"property":"article:published_time","content":"2024-12-10T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-02T13:54:50.000Z"}]]},"git":{"updatedTime":1759413290000,"contributors":[{"name":"MagicTable-RedmiNote12TPro-Android","username":"","email":"13459588094@163.com","commits":1},{"name":"MagicTable-HappinessHome-DebianLinux","username":"","email":"13459588094@163.com","commits":1}],"changelog":[{"hash":"ea490d819f6b9c38b6faf647221faa9808862172","time":1759413290000,"email":"13459588094@163.com","author":"MagicTable-HappinessHome-DebianLinux","message":"更新博客文章数据"},{"hash":"bd68b5c596d6a0543e6461d26edd64a5440f6020","time":1758421995000,"email":"13459588094@163.com","author":"MagicTable-RedmiNote12TPro-Android","message":"初始化仓库版本"}]},"autoDesc":true,"filePathRelative":"software/Algorithm-排序.md","excerpt":"<p><strong>文章摘要：</strong> 将一组数据按照特定的顺序排列的算法。</p>\\n"}');export{A as comp,f as data};
